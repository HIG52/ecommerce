# 이커머스 동시성 제어

트랜잭션의 격리 수준, 락에대한 공부

1. 상품의 재고 차감(주문)
   1. 동시에 상품에 대한 주문이 들어올경우 재고 차감이 순차적으로 일어나야 하며, 재고가 0이 될경우 이후 주문에 대한것들은 주문에 실패 하여야 한다. 
2. 결제시 잔액 차감
   1. 유저가 한 주문건에 대하여 여러번 결제 요청시 단 한번의 요청만이 이루어져야 한다.
3. 유저의 잔액 충전
   1. 한명의 유저가 여러번의 충전을 요청할경우 순차적으로 충전이 이루어져야 한다.
4. 선착순 쿠폰 발급
   1. 한정된 쿠폰재고에 있어서 순차적으로 발급해주어야 하며 재고가 다 소진될경우 쿠폰발급이 되면 안된다.

## Database Lock
### Lock의 종류
1. s-lock (Shared Lock, 공유 락)
   - 한쪽이 커밋 할 때 까지 쓰기 잠금
   - 다른 트랜잭션에서의 s-lock은 허용하지만 x-lock은 허용하지 않음

2. x-lock (Exclusive Lock, 배타 락)
   - 쓰기 잠금
   - x-lock을 설정한 트랜잭션은 해당 row에 대해 읽기/쓰기 작업 모두 수행 가능
   - x-lock이 설정된 경우 다른 트랜잭션은 해당 row에 대해 s, x-lock 모두 설정 불가능 -> 대기상태


### Lock을 이용한 동시성 제어
1. Optimistic Lock (낙관적 락)
   - 충돌 빈도가 적을 경우 권장
   - 동시 요청 중 한건만 성공해야 하는 케이스에 적합
   1. 사용 방법
   ```
   
   ```
2. Pessimistic Lock (비관적 락)
   - 충돌 빈도가 많을 경우 권장
   - 동시 요청에서 순차로 진행될 때 성공할 수 있는 요청이라면 성공시키는 케이스에 적합
   - 특정 자원에 대해 Lock설정으로 선점하여 정합성을 보장
   - s-lock 또는 x-lock을 걸고 다른 트랜잭션의 접근을 막음
   - 트래픽이 몰리는 경우나 여러테이블에 락을걸어 작업할경우 데드락이 발생할수도 있음

3. 분산 락
   - 분산시스템에서 서로 다른 서버 인스턴스에 대해 일관된 락을 제공하기 위한 장치
   - 분산된 서버/클러스터 간에도 lock을 보장하는것
   - 주로 key-value 기반의 원자성을 이용한 Redis를 통해 DB부하를 최소화하는 lock 설계

### 레디스를 활용한 대표적 방법들
1. Simple Lock
   - key 선점에 의한 lock 획득 실패 시, 비즈니스 로직을 수행하지 않음
   - 실패 시 재시도 로직에 대해 고려해야 하며 요청의 case에 따라 빈도가 높다.
2. Spin Lock
   - lock 획득 실패 시, 일정 시간/횟수 동안 Lock 획득을 재시도
   - 획득 실패시 지속적 재시도로 인해 비용증가, 스레드 점유등 문제 발생
3. Pub/Sub
   - redis pub/sub 구독 기능을 이용해 lock 제어
   - 락획득 실패시 ‘구독’하고 차례가 될때까지 이벤트를 기다리는 방식을 이용
   - ‘구독’한 sub들중 먼저 선점한 작업의 Lock헤제가 가능하므로 원자적 처리 가능
   - 직접 구현, 혹은 라이브러리를 이용할 때 해당 방식의 구현이 달라질 수 있으므로 주의해서 사용

* 트랜잭션 시작전 lock을 획득하고 트랜잭션을 진행하는것이 좋다.

현재 적용중인것은 전부 비관적락

낙관적락이 적용 가능한 부분이 있다면?
포인트 충전
결제 잔액차감

두개다 한명의 유저만이 접근가능한곳이라 충돌가능성이 낮음

비관적락이 적용 가능한 부분이 있다면?
재고 차감
선착순 쿠폰 발

